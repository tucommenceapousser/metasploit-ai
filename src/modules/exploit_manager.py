"""
Exploit Manager Module
Handles exploit execution and management through Metasploit
"""

import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid
import json

from ..utils.logger import get_logger


class ExploitManager:
    """Manages exploit execution and coordination with Metasploit"""
    
    def __init__(self, msf_client, config):
        """Initialize exploit manager"""
        self.msf_client = msf_client
        self.config = config
        self.logger = get_logger(__name__)
        
        # Active exploits tracking
        self.active_exploits: Dict[str, Dict] = {}
        self.exploit_history: List[Dict] = []
        
        # Exploit execution settings
        self.max_concurrent_exploits = getattr(config, 'max_concurrent_exploits', 5)
        self.default_timeout = getattr(config, 'exploit_timeout', 300)  # 5 minutes
        
        self.logger.info("🚀 Exploit Manager initialized")
    
    async def execute(self, target: str, exploit_name: str, payload: str, 
                     options: Dict = None) -> Dict:
        """Execute exploit against target"""
        exploit_id = str(uuid.uuid4())
        timestamp = datetime.now()
        
        self.logger.info(f"💥 Executing exploit {exploit_name} against {target}")
        
        # Create exploit session
        exploit_session = {
            'id': exploit_id,
            'target': target,
            'exploit_name': exploit_name,
            'payload': payload,
            'options': options or {},
            'status': 'initializing',
            'start_time': timestamp,
            'end_time': None,
            'success': False,
            'session_id': None,
            'error': None,
            'details': {}
        }
        
        self.active_exploits[exploit_id] = exploit_session
        
        try:
            # Prepare exploit module
            exploit_session['status'] = 'preparing'
            module_info = await self._prepare_exploit_module(exploit_name, options)
            
            if not module_info:
                raise Exception(f"Failed to prepare exploit module: {exploit_name}")
            
            # Set target and payload
            exploit_session['status'] = 'configuring'
            await self._configure_exploit(module_info, target, payload, options)
            
            # Execute exploit
            exploit_session['status'] = 'executing'
            execution_result = await self._execute_exploit(module_info, exploit_id)
            
            # Process results
            exploit_session.update({
                'status': 'completed',
                'end_time': datetime.now(),
                'success': execution_result['success'],
                'session_id': execution_result.get('session_id'),
                'details': execution_result
            })
            
            if execution_result['success']:
                self.logger.info(f"✅ Exploit {exploit_name} succeeded against {target}")
                
                # Handle successful session
                if execution_result.get('session_id'):
                    await self._handle_new_session(execution_result['session_id'], exploit_session)
            else:
                self.logger.warning(f"❌ Exploit {exploit_name} failed against {target}")
                exploit_session['error'] = execution_result.get('error', 'Unknown failure')
            
            return {
                'exploit_id': exploit_id,
                'success': exploit_session['success'],
                'session_id': exploit_session.get('session_id'),
                'details': exploit_session['details'],
                'error': exploit_session.get('error')
            }
            
        except Exception as e:
            self.logger.error(f"💥 Exploit execution failed: {e}")
            exploit_session.update({
                'status': 'failed',
                'end_time': datetime.now(),
                'success': False,
                'error': str(e)
            })
            
            return {
                'exploit_id': exploit_id,
                'success': False,
                'error': str(e),
                'details': {}
            }
        
        finally:
            # Move to history and cleanup
            self.exploit_history.append(exploit_session.copy())
            if exploit_id in self.active_exploits:
                del self.active_exploits[exploit_id]
    
    async def _prepare_exploit_module(self, exploit_name: str, options: Dict) -> Optional[Dict]:
        """Prepare exploit module in Metasploit"""
        try:
            # Use the exploit module
            use_result = await self.msf_client.execute_command('use', exploit_name)
            if not use_result.get('success', False):
                self.logger.error(f"Failed to use exploit module: {exploit_name}")
                return None
            
            # Get module information
            module_info = await self.msf_client.get_module_info(exploit_name)
            if not module_info:
                self.logger.error(f"Failed to get module info for: {exploit_name}")
                return None
            
            self.logger.info(f"📋 Prepared exploit module: {exploit_name}")
            return module_info
            
        except Exception as e:
            self.logger.error(f"Failed to prepare exploit module: {e}")
            return None
    
    async def _configure_exploit(self, module_info: Dict, target: str, 
                                payload: str, options: Dict):
        """Configure exploit parameters"""
        try:
            # Set RHOSTS (target)
            await self.msf_client.set_option('RHOSTS', target)
            self.logger.debug(f"Set RHOSTS to {target}")
            
            # Set payload if provided
            if payload:
                await self.msf_client.set_option('PAYLOAD', payload)
                self.logger.debug(f"Set PAYLOAD to {payload}")
            
            # Set additional options
            for key, value in options.items():
                if key.upper() not in ['RHOSTS', 'PAYLOAD']:  # Avoid duplicates
                    await self.msf_client.set_option(key, value)
                    self.logger.debug(f"Set {key} to {value}")
            
            # Set common options if not provided
            default_options = {
                'LHOST': options.get('LHOST', self._get_local_ip()),
                'LPORT': options.get('LPORT', '4444'),
                'EXITFUNC': options.get('EXITFUNC', 'thread')
            }
            
            for key, value in default_options.items():
                if key not in options:
                    await self.msf_client.set_option(key, value)
                    self.logger.debug(f"Set default {key} to {value}")
            
        except Exception as e:
            self.logger.error(f"Failed to configure exploit: {e}")
            raise
    
    async def _execute_exploit(self, module_info: Dict, exploit_id: str) -> Dict:
        """Execute the configured exploit"""
        try:
            self.logger.info(f"🎯 Launching exploit...")
            
            # Execute the exploit
            result = await self.msf_client.execute_command('exploit', '-j')  # Background job
            
            if not result.get('success', False):
                return {
                    'success': False,
                    'error': result.get('error', 'Exploit execution failed'),
                    'job_id': None,
                    'session_id': None
                }
            
            job_id = result.get('job_id')
            if job_id:
                self.logger.info(f"📝 Exploit running as job {job_id}")
                
                # Wait for completion or timeout
                session_id = await self._wait_for_session(job_id, self.default_timeout)
                
                if session_id:
                    return {
                        'success': True,
                        'job_id': job_id,
                        'session_id': session_id,
                        'message': f'Session {session_id} opened'
                    }
                else:
                    return {
                        'success': False,
                        'job_id': job_id,
                        'session_id': None,
                        'error': 'No session created within timeout period'
                    }
            else:
                return {
                    'success': False,
                    'error': 'No job ID returned from exploit',
                    'job_id': None,
                    'session_id': None
                }
            
        except Exception as e:
            self.logger.error(f"Exploit execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'job_id': None,
                'session_id': None
            }
    
    async def _wait_for_session(self, job_id: str, timeout: int) -> Optional[str]:
        """Wait for exploit to create a session"""
        start_time = datetime.now()
        
        while (datetime.now() - start_time).seconds < timeout:
            try:
                # Check for new sessions
                sessions = await self.msf_client.get_sessions()
                
                # Look for newest session
                if sessions:
                    # Get the most recent session
                    latest_session = max(sessions.keys()) if sessions else None
                    if latest_session:
                        self.logger.info(f"🎉 Session {latest_session} created!")
                        return latest_session
                
                # Check job status
                jobs = await self.msf_client.get_jobs()
                if job_id not in jobs:
                    # Job completed, check once more for sessions
                    await asyncio.sleep(1)
                    sessions = await self.msf_client.get_sessions()
                    if sessions:
                        latest_session = max(sessions.keys())
                        return latest_session
                    break
                
                await asyncio.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.logger.error(f"Error checking for session: {e}")
                await asyncio.sleep(2)
        
        self.logger.warning(f"⏰ Timeout waiting for session from job {job_id}")
        return None
    
    async def _handle_new_session(self, session_id: str, exploit_session: Dict):
        """Handle newly created session"""
        try:
            session_info = await self.msf_client.get_session_info(session_id)
            
            self.logger.info(f"🖥️ New session {session_id}: {session_info.get('info', 'Unknown')}")
            
            # Store session details
            exploit_session['session_info'] = session_info
            
            # Perform initial session commands if configured
            initial_commands = getattr(self.config, 'initial_session_commands', [])
            for command in initial_commands:
                try:
                    await self.msf_client.execute_session_command(session_id, command)
                    self.logger.debug(f"Executed initial command: {command}")
                except Exception as e:
                    self.logger.warning(f"Failed to execute initial command '{command}': {e}")
            
        except Exception as e:
            self.logger.error(f"Failed to handle new session: {e}")
    
    def _get_local_ip(self) -> str:
        """Get local IP address for LHOST"""
        try:
            import socket
            # Create a socket and connect to a remote address to get local IP
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except Exception:
            return "127.0.0.1"  # Fallback to localhost
    
    async def list_available_exploits(self, platform: str = None) -> List[Dict]:
        """List available exploits"""
        try:
            exploits = await self.msf_client.get_exploits()
            
            if platform:
                # Filter by platform
                filtered_exploits = []
                for exploit in exploits:
                    if platform.lower() in exploit.get('platform', '').lower():
                        filtered_exploits.append(exploit)
                return filtered_exploits
            
            return exploits
            
        except Exception as e:
            self.logger.error(f"Failed to list exploits: {e}")
            return []
    
    async def get_exploit_info(self, exploit_name: str) -> Optional[Dict]:
        """Get detailed information about an exploit"""
        try:
            return await self.msf_client.get_module_info(exploit_name)
        except Exception as e:
            self.logger.error(f"Failed to get exploit info: {e}")
            return None
    
    async def stop_exploit(self, exploit_id: str) -> bool:
        """Stop a running exploit"""
        try:
            if exploit_id in self.active_exploits:
                exploit_session = self.active_exploits[exploit_id]
                
                # Stop the job if it's running
                if exploit_session.get('job_id'):
                    await self.msf_client.kill_job(exploit_session['job_id'])
                
                exploit_session['status'] = 'stopped'
                exploit_session['end_time'] = datetime.now()
                
                self.logger.info(f"🛑 Stopped exploit {exploit_id}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Failed to stop exploit: {e}")
            return False
    
    def get_exploit_status(self, exploit_id: str) -> Optional[Dict]:
        """Get status of an exploit"""
        return self.active_exploits.get(exploit_id)
    
    def get_active_exploits(self) -> Dict[str, Dict]:
        """Get all active exploits"""
        return self.active_exploits.copy()
    
    def get_exploit_history(self) -> List[Dict]:
        """Get exploit execution history"""
        return self.exploit_history.copy()
    
    def get_statistics(self) -> Dict:
        """Get exploit manager statistics"""
        total_exploits = len(self.exploit_history)
        successful_exploits = sum(1 for exploit in self.exploit_history if exploit['success'])
        
        return {
            'total_exploits': total_exploits,
            'successful_exploits': successful_exploits,
            'success_rate': (successful_exploits / total_exploits * 100) if total_exploits > 0 else 0,
            'active_exploits': len(self.active_exploits),
            'available_exploits': len(self.available_exploits)
        }
